* emacs quest 

Assisting kartbala in his Emacs quest for low vision.

This document specify the steps I used to replicate and develop kartabala/emacs. 
It is a live document meant to be read inside emacs (github.com does not display some blocks and other useful information!) 
Some of the org-block are meant to be evaluated in emacs with ﴾ C-c C-c \ (org-ctrl-c-ctrl-c) ﴿, to evaluate sh/bash blocks, ob-shell is required. some are meant to be tangled with ﴾ C-c C-v C-t / (org-babel-tangle) ﴿, a block can be tangled alone by adding an universal-argument ﴾ C-u C-c C-v C-t ﴿.
*Warning : tangling will override any files already present!*

#+begin_src emacs-lisp
(require 'ob-shell)
#+end_src

** mail configuration

So to get mu4e working I used :
 - a imap client (popular choices are offlineimap or isync) to get mails
 - a smtp client (built-in emacs) to send mails
 - a way to specify the authentification (.authinfo.gpg) file
 - a way to protect our authenfification (gpg)

*** mu4e package declaration :week1:

I used an use-package declaration to install ~mu4e~. If you have it installed (you may have to install it via your package manager or compile ~mu~), it should work out of the box after you set in the load-path, the maildir, the mu4e info dir, and the mu binary ; You can ignore for now the mu4e-contexts, it will not throw an error for it.

#+begin_src emacs-lisp
;; * Email
;; ** authentification
;; emacs document its authentification
;; mechanisms at --evaluate it-- :
;; (info "(auth) Help for users")
;; In a nutshell, credentials can be
;; stored in .authinfo or .netrc
;; it can be encrypted
;; and elisp programs can query it.
;; I used to specify the passwords
;; myself, so don't ask to save it.
(setq auth-source-save-behavior nil)
;; offlineimap will use emacs as a
;; client, we need to start the server.
(server-start)
;; ** mu4e package declaration
(use-package mu4e
    :ensure nil
    :load-path (expand-file-name "<path to the elips mu4e library>")
;; ** mu4e custom variables
    :custom
;; I think if you want multiple accounts it is:
;; simply, a directory, eg : "~/Maildir/"
    (mu4e-maildir (expand-file-name "<path to your maildir>"  ))
    (mu4e-mu-binary (expand-file-name "<path to the mu executable>" ))
    (Info-directory-list (add-to-list 'Info-directory-list
                                      (expand-file-name "<path to the mu4e info dir>")))
;; *** crypto
;; do you want to sign messages with pgp ?
    ;; (setq mu4e-compose-crypto-reply-policy 'sign-and-encrypt)
    (mml-secure-openpgp-sign-with-sender t)
    (mml-secure-openpgp-encrypt-to-self t)
;; *** be nice for the imap indexer
    (mu4e-compose-dont-reply-to-self t)
    (mu4e-change-filenames-when-moving t)
;; *** Fetching mail
    ;; the debian stable mu is buggy,
    ;; just verify it works reliably.
    (mu4e-get-mail-command "offlineimap")
;; *** Message view
    ;; nil to display only the headers
    ;; or the message at once
    (mu4e-split-view 'single-window)
    ;; this is more promising
    (mu4e-view-use-gnus t)
    (mu4e-headers-include-related t)
    (mu4e-headers-skip-duplicates t)
    (mu4e-headers-show-threads nil)
    (mu4e-view-show-addresses t)
    (mu4e-headers-fields
     '((:human-date . 8)
       (:from . 16)
       (:subject)))
    ;; americans will agree ?
    (mu4e-headers-date-format "%d/%m/%Y")
    (mu4e-headers-time-format "%H:%M")
    ;; enable notifications
    (mu4e-enable-mode-line t)
    ;; try to show images ?
    (mu4e-view-show-images t)
    (mu4e-view-image-max-width 800)
    ;; plain text messages
    ;; (setq mu4e-view-html-plaintext-ratio-heuristic most-positive-fixnum)
;; *** context policy
    ;; start with the first context
    ;; the contexts themselves will
    ;; be defined later
    (mu4e-context-policy 'pick-first)
    (mu4e-compose-context-policy 'automatic)
    ;; set mail user agent globally
    ;; for emacs so it is reconized for
    ;; eg send a bug report
    (mail-user-agent 'mu4e-user-agent)
;; *** sent message behavior
    ;; note this is mostly for gmail because
    ;; it already save all sent messages
    ;; we may want tune it
    ;; specifically by context
    (mu4e-sent-messages-behavior 'delete)
;; *** wrapping message body
;; visual-line-mode + auto-fill upon sending
    ;; autofill may be annoying though
    ;; also I have a known bug with it
    (mu4e-compose-format-flowed nil)
;; *** Autocomplete addresses
    (mu4e-compose-complete-addresses t)
    (mu4e-compose-complete-only-after "2020-01-01")
    (mu4e-compose-complete-only-personal t)
;; *** misc
    (mu4e-attachment-dir "~/Downloads")
    ;; don't keep message buffers around
    (message-kill-buffer-on-exit t)
    ;; use TAB and <backtab> to jump to links
    ;; works well with gnus-view
    (with-eval-after-load 'mu4e-view
      (set-keymap-parent mu4e-view-mode-map button-buffer-map))
    ;; must mu4e be verbose ?
    (mu4e-hide-index-messages t)
;; ** mu4e configurations
    :config
    ;; display message in a browser
    (add-to-list 'mu4e-view-actions
                 '("browser" . mu4e-action-view-in-browser) t)
    ;; update the database every ten minutes.
    (setq mu4e-update-interval 600)
    ;; load the differents contexts
    (or (require 'mu4e-personal-context nil t)
        (warn "mu4e-personal-context.el not found"))
;; ** mu4e patch
    ;; make the call to mu4e more DWIM
    ;; by calling the dispatch menu again
    ;; when we already see the headers
    (advice-add 'mu4e~main-view :override
            (defun patch-mu4e~main-view (&optional refresh)
  "Create the mu4e main-view, and switch to it.

When REFRESH is non nil refresh infos from server."
  (let ((buf (get-buffer-create mu4e-main-buffer-name))
        (headers-buffer (mu4e-get-headers-buffer)))
    (if (eq mu4e-split-view 'single-window)
        (cond ((not (buffer-live-p headers-buffer))
               (mu4e~main-menu))
              ((eq (window-old-buffer) headers-buffer)
               (mu4e~main-menu))
              (t (switch-to-buffer headers-buffer)))
      ;; `mu4e~main-view' is called from `mu4e~start', so don't call it
      ;; a second time here i.e. do not refresh unless specified
      ;; explicitely with REFRESH arg.
      (switch-to-buffer buf)
      (with-current-buffer buf
        (mu4e~main-view-real-1 refresh))
      (goto-char (point-min)))
    (add-to-list 'global-mode-string '(:eval (mu4e-context-label))))))
;; ** mu4e initialisation
    :init
    ;; helper for authentification
    (defun offlineimap-get-password (machine user port)
     "Get the password of ~/.authinfo.gpg from its MACHINE, USER, PORT."
     (require 'netrc)
     (let* ((netrc (netrc-parse
                    (expand-file-name "~/.authinfo.gpg")))
            credentials password)
      (catch 'password
       (dolist (credentials netrc)
        (when (netrc-machine (list credentials) machine)
         (dolist (lst credentials)
          (when (and (string= (cdr (assoc "login" credentials)) user)
                     (string= (cdr (assoc "port" credentials)) port))
           (throw 'password (cdr (assoc "password" credentials))))))))))
    :bind
    ("<f12>" . mu4e))

;; ** Sending mail
(use-package smtpmail
    :ensure nil
    :custom
    (smtp-auth-credentials
     (expand-file-name "~/.authinfo.gpg"))
    ;; start in normal mode (default)
    ;; (smtpmail-queue-mail nil)
;; *** debugging
    ;; (smtp-debug-information t)
    ;; (smtp-debug-verbose t)
;; *** actually sending mail
    (message-send-mail-function
     'smtpmail-send-it))

;; ** Composing mail
;; use org for rich text emails
(use-package org-mu4e
    :ensure nil
    :after mu4e
    :custom
    (org-mu4e-convert-to-html t)
    :bind
    (:map mu4e-headers-mode-map
          ("C-c c" . org-mu4e-store-and-capture))
    (:map mu4e-view-mode-map
          ("C-c c" . org-mu4e-store-and-capture)))
#+end_src

*** .offlineimaprc :week1:
This is a simple offlineimap configuration file, it specifies the accounts, eventually the folders to sync, the passwords and the certificates of the mail provider.

https://stackoverflow.com/questions/24675167/ca-certificates-mac-os-x
It seems there is two ways to get the certificate on macos:
 - or export them from the keychain
 - or install openssl, it will also export them into /usr/local/etc/openssl/cert.pem from the keychain.

The password can be specified in plain text inside this document with a `remotepass = <password>` instead of the `remotepasseval = <pythonfunc(args)>, it is useful to do so when testing the file, once it is done,  I implemented a more secure way to store them.

Gmail have a particular way to rely on labels and this may leads to a massive duplication of emails in your IMAP folder. [[https://mail.google.com/mail/u/0/#settings/labels][Please adjust the labels accordingly]].

#+begin_src conf :tangle ~/.offlineimaprc
[general]
# adjust here the name and number of accounts
accounts = lazysnail2077, 2077snaillazy
maxsyncaccounts = 2
ui=TTYUI
socktimeout = 60
# password management functions
pythonfile = ~/.offlineimap.py

## account 1
[Account lazysnail2077]
localrepository = Local-lazysnail2077
remoterepository = Remote-lazysnail2077

[Repository Local-lazysnail2077]
type = Maildir
localfolders = ~/.mail/lazysnail2077

[Repository Remote-lazysnail2077]
type = Gmail
remotehost = imap.gmail.com
remoteuser = lazysnail2077@gmail.com
remotepasseval = get_password_emacs("imap.gmail.com", "lazysnail2077@gmail.com", "993")
ssl = yes
sslcacertfile = /etc/ssl/certs/ca-certificates.crt
maxconnections = 2
# folder(s)? to exclude
# All Mail seems to be a constant source of duplicates
folderfilter = lambda foldername: foldername not in ['[Gmail]/All Mail']

## account 2
[Account 2077snaillazy]
localrepository = Local-2077snaillazy
remoterepository = Remote-2077snaillazy

[Repository Local-2077snaillazy]
type = Maildir
localfolders = ~/.mail/2077snaillazy

[Repository Remote-2077snaillazy]
type = Gmail
remotehost = imap.gmail.com
remoteuser = 2077snaillazy@gmail.com
remotepasseval = get_password_emacs("imap.gmail.com", "2077snaillazy@gmail.com", "993")
ssl = yes
sslcacertfile = /etc/ssl/certs/ca-certificates.crt
maxconnections = 2
folderfilter = lambda foldername: foldername not in ['[Gmail]/All Mail']
#+end_src

*** gpg key

I rely on encryption to secure my credentials rather than relying on the security of tiers services.

Here a simple memo :

**** creation :week1:

the simplest way get a pair of gpg key is to create them interactively in a terminal:
#+begin_src bash :eval no
gpg2 --full-generate-key
#+end_src

And that is pretty all with gpg alone, now we can uses this key inside emacs and with other softwares.

*this didn't worked on mac*

**** in batch mode :week2:

Unfortunately maybe your terminal or emacs is not able on your computer to use your graphical server to ask passwords, so you may need to create a key in batch mode instead :

#+begin_src bash :results pp
# temporary prevent history
unset HISTFILE
# comment the next line to make a durable key
export GNUPGHOME="$(mktemp -d)"
# create a specification file in /tmp/crypto
cat > /tmp/crypto <<EOF
     %echo Generating a basic OpenPGP key
     Key-Type: default
     Key-Length: 4096
     Subkey-Type: default
     Subkey-Length: 4096
     Name-Real: John Duh
     Name-Comment: eventually
     Name-Email: mymail@gmail.com.
     Expire-Date: 0
     Passphrase: very-secure-password
     %commit
     %echo done
EOF
# redirection only to get the output in org-mode
2<&1 gpg --batch --generate-key /tmp/crypto
# clear your traces.
rm /tmp/crypto
#+end_src

#+RESULTS:
: gpg: keybox '/tmp/tmp.UdBqBAWACV/pubring.kbx' created
: gpg: Generating a basic OpenPGP key
: gpg: /tmp/tmp.UdBqBAWACV/trustdb.gpg: trustdb created
: gpg: key D084633A29F0D54E marked as ultimately trusted
: gpg: directory '/tmp/tmp.UdBqBAWACV/openpgp-revocs.d' created
: gpg: revocation certificate stored as '/tmp/tmp.UdBqBAWACV/openpgp-revocs.d/F3D6DE5627A10F4D8CDAE84CD084633A29F0D54E.rev'
: gpg: done

*that didn't worked again on mac*
Big sur was complaining about more parameters :/

**** again interactively :week3:

So I figured out that if it didn't worked interactively the first time, it was because its computer was lacking a pinentry package such as ~pinentry-mac~ after installing it, it still didn't worked neither.

[[https://stackoverflow.com/questions/41502146/git-gpg-onto-mac-osx-error-gpg-failed-to-sign-the-data][I think it may be about the =gpg.conf= file.]]

#+begin_src sh
echo "pinentry-program /usr/local/bin/pinentry-mac" >> ~/.gnupg/gpg-agent.conf
test -r ~/.zshrc && echo 'export GPG_TTY=$(tty)' >> ~/.zshrc
echo 'export GPG_TTY=$(tty)' >> ~/.profile
#+end_src

And eventually need to ‘source ~/.zshrc’ to get updated a current session.
*And eventually need to reboot*

**** (optional) sharing our id :week1:
now eventually we can declare ourselves to keyservers. This may be helpful for eg signing a FSF assessment.

first check our fingerprint :
#+begin_src bash :results pp
gpg --fingerprint lazysnail2077@gmail.com
#+end_src

#+RESULTS:
: pub   rsa4096 2021-05-28 [SC]
:       E9AF 49C4 6F8E AE92 139D  F319 4814 7806 2064 2A11
: uid           [ultimate] Lazy Snail <lazysnail2077@gmail.com>
: sub   rsa4096 2021-05-28 [E]
:

E9AF 49C4 6F8E AE92 139D  F319 4814 7806 2064 2A11
is the fingerprint,
4814 7806 2064 2A11
is the long key id
2064 2A11
is the short key id

So finally we can send it to the keyservers of our choice :
#+begin_src bash
gpg2 --keyserver keys.gnupg.net --search "20642A11"
#+end_src

and verify it worked :
#+begin_src bash
gpg2 --keyserver keys.gnupg.net --search "20642A11"
#+end_src

the server should return the mail address we initially specified.

**** (optional) going beyond :week1:
This setup may be enhanced by creating a signing subkey and keeping our master key and revocation certificate in, eg a cold storage.
https://alexcabal.com/creating-the-perfect-gpg-keypair

*** authinfo :week1:
[[elisp:(info "(auth) Help for users")][authinfo manual]]
By creating this file as =~/.authinfo.gpg= with emacs, emacs will automatically recognize it is an encrypted file and ask you which gpg key you wish to use when needed.
The format of netrc|authinfo file is quite simple when we get it:
#+begin_example
machine imap.gmail.com port 993 login this.is@mail.net password very-secure-password
machine smtp.gmail.com port 587 login this.is@mail.net password very-secure-password
machine imap.gmail.com port 993 login another@mail.net password very-much-secure-password
machine smtp.gmail.com port 587 login another@mail.net password very-much-secure-password
#+end_example

*** .offlineimap.py :week1:
This setup imply to start emacs as a server with emacsclient:

To start an emacsclient session, you can type in a terminal `emacsclient -c -a ""`, or use ~server-start~ from inside an emacs session.
To kill the server and emacs I can use `pkill emacs`.

credits to https://www.emacswiki.org/emacs/OfflineIMAP with little modifications:
#+begin_src python :tangle "~/.offlineimap.py" :shebang "#!/bin/python"
  import subprocess
  def get_output(cmd):
  # Bunch of boilerplate to catch the output of a command:
	pipe = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
	(output, errout) = pipe.communicate()
	assert pipe.returncode == 0 and not errout
	return output
  def get_password_emacs(host, user, port):
	cmd = "emacsclient --eval '(offlineimap-get-password \"%s\" \"%s\" \"%s\")'" % (host,user,port)
	return get_output(cmd).strip().lstrip('"').rstrip('"')
#+end_src

*** offlineimap-get-password :week1:
From the offlineimap documentation :
#+begin_quote
#    If a matching entry is found in ~/.netrc (see netrc (5) for
#    information) this password will be used. Do note that netrc only
#    allows one entry per hostname.
#+end_quote
I realized nor the original script of emacswiki nor the offlineimap mechanism would cut it. They are designed to get only one user per machine/port, or force you to use multiple files, this is not what I wanted, and we may have multiple accounts from the same machine/port.
Thankfully to ~netrc.el~, the solution can be abstracted without too much boilerplate:
#+begin_src emacs-lisp :results pp
  (defun offlineimap-get-password (machine user port)
    "Get the password of a .netrc file from its MACHINE, USER, PORT."
    (require 'netrc)
    (let* ((netrc (netrc-parse
		   (expand-file-name "~/.authinfo.gpg")))
	   credentials password)
      (catch 'password
	(dolist (credentials netrc)
	  (when (netrc-machine (list credentials) machine)
	    (dolist (lst credentials)
	      (when (and (string= (cdr (assoc "login" credentials)) user)
			 (string= (cdr (assoc "port" credentials)) port))
		(throw 'password (cdr (assoc "password" credentials))))))))))

  (offlineimap-get-password "imap.gmail.com" "lazysnail2077@gmail.com" "993")
#+end_src

*** offlineimap dry run :week1:

Make a dry run to test the setup and eventually get the informations about your mail folders:

#+begin_src sh
offlineimap --dry-run
#+end_src

~offlineimap~ will throw errors with --dry-run when it is not yet initialized.
This is a known bug, confusing, disturbing, but known.
So when using --dry-run to see the mailboxes creations with your =.offlineimaprc= settings, keep this in mind.

*Always backup your local mailboxes before implementing new configurations!*

*** specific mail providers configuration :week4:

I would recommend to *not* use gmail or outlook. Not only they are proprietary services that are actively building a permanent record on you, but also they make a lot of things harder that it has to be by denying you many security decisions, taking away your time, forcing you to give more personal informations than necessary. Because you are already making the effort to setup your MUA, it may be appropriate to also take the time to get a better mail provider than a spy ;)

But maybe you have no choice... so, let's see the extra steps they are requiring :

+ for gmail :

 - activate IMAP in the gmail settings
 - authorize "the less trusted applications"
 - disconnect
 - reconnect and validate in the security logs that's me who authorized the previous step.
 - It may be necessary to go to a page validating a captcha ???

It may not work yet and nobody will reliably tell you why. take a tea.
then try to authenticate again with your IMAP client :

+ For outlook :

We do not find a way to get right the imap and the smtp without relying on tiers software.
For some obscure reason there were always something wrong with their ‘modern authentification’. App password or not, that was not working. I get it by creating an alias of an outlook account, but that is something you may be also denied to do.

So we installed [[http://davmail.sourceforge.net/gettingstarted.html][davmail]]. Once installed, the configuration is really straightforward (you probably just have to get your .authinfo and .offlineimap to point to localhost with the right port and an app password).

Apart that you may want to see the davmail configuration file (that is located at /etc/davmail.properties on debian) and if you use offlineimap, to set :

#+begin_example
davmail.enableKeepAlive=false
#+end_example

Note that outlook locked my account after a few days, requiring for some reason that in top of a double authentification I also provide a phone number. I won't miss it.

*** initialize mu :week1:

Once the IMAP client is setup, we can initialize mu and index.
#+begin_src sh
mu init --maildir ~/.mail              \
  --my-address=2077snaillazy@gmail.com \
  --my-address=lazysnail2077@gmail.com
mu index
#+end_src

*** contexts  :week1:week4:week5:
:PROPERTIES:
:header-args: :tangle "mu4e-personal-context.el" :results pp :wrap "src emacs-lisp :tangle no" 
:END:

~mu4e~ allow to have multiple mail adress in the same setup. It is a good idea to defines these settings in a separate file from your main emacs configuration so it can be easily ignored by git with the =.gitignore= file, eg in ~user-emacs-directory~ =./personal/mu4e-contexts.el=

I am not sure how much I am complicating the things out of necessity with my template. What I know is [[elisp:(info "(mu4e) Contexts example")][editing multiple contexts as an unique sexp]] with levels and backquotes is an operation that is proportionnaly difficult to the number of contexts you add. 

So here an helper function to get one context at a time based on the context-name, while preventing us to dupplicate contexts on multiple evaluation that may happen when tweaking the settings.

#+begin_src emacs-lisp :results silent
;; * helper
(cl-defun create-or-update-mu4e-context
    (&key name enter-func leave-func match-func vars)
  "Wrapper around `make-mu4e-context',
to make a mu4e-context at a time,
update the `mu4e-contexts' list,
while avoiding duplicating elements
with the same context name."
  (let ((new-context
         (make-mu4e-context
          :name       name
          :enter-func enter-func
          :leave-func leave-func
          :match-func match-func
          :vars       vars)))
    ;; try to find if this
    ;; context is already here
    (if-let
        ((mu4e-context
          (catch 'context
            (dolist (mu4e-context mu4e-contexts)
              (when (string=
                     name
                     (mu4e-context-name mu4e-context))
                (throw 'context mu4e-context))))))
        ;; so replace the old with the new
        (setf (car (memq mu4e-context mu4e-contexts))
              new-context)
      ;; otherwise push the new
      (push new-context mu4e-contexts))
    new-context))
#+end_src

The next blocks will be tangled into "mu4e-personal-context.el", in the same directory. They produce on evaluation a pretty-printed result to let us inspect their correctness.

If you changed of contexts names, you can always start again from 0 by erasing the whole list :

#+begin_src emacs-lisp :results silent :tangle no
(setq mu4e-contexts nil)
#+end_src

**** lazysnail2077@gmail.com

#+begin_src  emacs-lisp 
;; * lazysnail2077@gmail.com
(let* ((context-name "L")
       (user-name "lazysnail2077")
       (address "lazysnail2077@gmail.com")
       (full-name "Lazy Snail"))
  (create-or-update-mu4e-context
   :name
   context-name
;; ** functions
   :enter-func
   `(lambda ()
      (mu4e-message
       ,(concat "Hello " address)))
   :leave-func
   `(lambda ()
      (mu4e-message
       ,(concat "Bye " address)))
   :match-func
   `(lambda (msg)
      (when msg
        (string-match-p
         (concat "^/" ,user-name "/")
         (mu4e-message-field
          msg :maildir))))
   :vars
   `((user-mail-address . ,address)
     (user-full-name . ,full-name)
     (mu4e-compose-signature
      . "")
;; **  inbox settings
     ;; initialise the folders otherwise
     ;; it will uses and creates defaults ones
     (mu4e-trash-folder
      . ,(concat "/" user-name
                 "/[Gmail].Trash"))
     (mu4e-sent-folder
      . ,(concat "/" user-name
                 "/[Gmail].Sent Mail"))
     (mu4e-drafts-folder
      . ,(concat "/" user-name
                 "/[Gmail].Drafts"))
     (mu4e-maildir-shortcuts
      . ((,(concat "/" user-name "/INBOX") . ?i)
         (,(concat "/" user-name "/[Gmail].Trash") . ?t)
         (,(concat "/" user-name "/[Gmail].Sent Mail") . ?s)
         (,(concat "/" user-name "/[Gmail].Spam") . ?S)))
;; **  smtp configuration
     (smtpmail-queue-dir
      . ,(concat "~/.mail/" user-name "/queue/cur"))
     (smtpmail-smtp-user . ,user-name)
     (smtpmail-mail-address . ,address)
     (smtpmail-smtp-server . "smtp.gmail.com")
     (smtpmail-smtp-service . 587))))
#+end_src

#+RESULTS:
#+begin_src emacs-lisp :tangle no
#s(mu4e-context "L"
                (lambda nil
                  (mu4e-message "Hello lazysnail2077@gmail.com"))
                (lambda nil
                  (mu4e-message "Bye lazysnail2077@gmail.com"))
                (lambda
                  (msg)
                  (when msg
                    (string-match-p
                     (concat "^/" "lazysnail2077" "/")
                     (mu4e-message-field msg :maildir))))
                ((user-mail-address . "lazysnail2077@gmail.com")
                 (user-full-name . "Lazy Snail")
                 (mu4e-compose-signature . "")
                 (mu4e-trash-folder . "/lazysnail2077/[Gmail].Trash")
                 (mu4e-sent-folder . "/lazysnail2077/[Gmail].Sent Mail")
                 (mu4e-drafts-folder . "/lazysnail2077/[Gmail].Drafts")
                 (mu4e-maildir-shortcuts
                  ("/lazysnail2077/INBOX" . 105)
                  ("/lazysnail2077/[Gmail].Trash" . 116)
                  ("/lazysnail2077/[Gmail].Sent Mail" . 115)
                  ("/lazysnail2077/[Gmail].Spam" . 83))
                 (smtpmail-queue-dir . "~/.mail/lazysnail2077/queue/cur")
                 (smtpmail-smtp-user . "lazysnail2077")
                 (smtpmail-mail-address . "lazysnail2077@gmail.com")
                 (smtpmail-smtp-server . "smtp.gmail.com")
                 (smtpmail-smtp-service . 587)))
#+end_src

**** 2077snaillazy@gmail.com

#+begin_src  emacs-lisp
;; * 2077snaillazy@gmail.com
(let* ((context-name "2")
       (user-name "2077snaillazy")
       (address "2077snaillazy@gmail.com")
       (full-name "Snail Lazy"))

  (create-or-update-mu4e-context
   :name
   context-name
;; ** functions
   :enter-func
   `(lambda ()
      (mu4e-message
       ,(concat "Hello " address)))
   :leave-func
   `(lambda ()
      (mu4e-message
       ,(concat "Bye " address)))
   :match-func
   `(lambda (msg)
      (when msg
        (string-match-p
         (concat "^/" ,user-name "/")
         (mu4e-message-field
          msg :maildir))))
   :vars
   `((user-mail-address . ,address)
     (user-full-name . ,full-name)
     (mu4e-compose-signature
      . "")
;; **  inbox settings
     ;; initialise the folders otherwise
     ;; it will uses and creates defaults ones
     (mu4e-trash-folder
      . ,(concat "/" user-name
                 "/[Gmail].Trash"))
     (mu4e-sent-folder
      . ,(concat "/" user-name
                 "/[Gmail].Sent Mail"))
     (mu4e-drafts-folder
      . ,(concat "/" user-name
                 "/[Gmail].Drafts"))
     (mu4e-maildir-shortcuts
      . ((,(concat "/" user-name "/INBOX") . ?i)
         (,(concat "/" user-name "/[Gmail].Trash") . ?t)
         (,(concat "/" user-name "/[Gmail].Sent Mail") . ?s)
         (,(concat "/" user-name "/[Gmail].Spam") . ?S)))
;; **  smtp configuration
     (smtpmail-queue-dir
      . ,(concat "~/.mail/" user-name "/queue/cur"))
     (smtpmail-smtp-user . ,user-name)
     (smtpmail-mail-address . ,address)
     (smtpmail-smtp-server . "smtp.gmail.com")
     (smtpmail-smtp-service . 587))))
#+end_src

#+RESULTS:
#+begin_src emacs-lisp :tangle no
#s(mu4e-context "2"
                (lambda nil
                  (mu4e-message "Hello 2077snaillazy@gmail.com"))
                (lambda nil
                  (mu4e-message "Bye 2077snaillazy@gmail.com"))
                (lambda
                  (msg)
                  (when msg
                    (string-match-p
                     (concat "^/" "2077snaillazy" "/")
                     (mu4e-message-field msg :maildir))))
                ((user-mail-address . "2077snaillazy@gmail.com")
                 (user-full-name . "Snail Lazy")
                 (mu4e-compose-signature . "")
                 (mu4e-trash-folder . "/2077snaillazy/[Gmail].Trash")
                 (mu4e-sent-folder . "/2077snaillazy/[Gmail].Sent Mail")
                 (mu4e-drafts-folder . "/2077snaillazy/[Gmail].Drafts")
                 (mu4e-maildir-shortcuts
                  ("/2077snaillazy/INBOX" . 105)
                  ("/2077snaillazy/[Gmail].Trash" . 116)
                  ("/2077snaillazy/[Gmail].Sent Mail" . 115)
                  ("/2077snaillazy/[Gmail].Spam" . 83))
                 (smtpmail-queue-dir . "~/.mail/2077snaillazy/queue/cur")
                 (smtpmail-smtp-user . "2077snaillazy")
                 (smtpmail-mail-address . "2077snaillazy@gmail.com")
                 (smtpmail-smtp-server . "smtp.gmail.com")
                 (smtpmail-smtp-service . 587)))
#+end_src

**** verify all contexts ?

#+begin_src emacs-lisp :tangle no
mu4e-contexts
#+end_src

#+RESULTS:
#+begin_src emacs-lisp :tangle no
(#s(mu4e-context "2"
                 (lambda nil
                   (mu4e-message "Hello 2077snaillazy@gmail.com"))
                 (lambda nil
                   (mu4e-message "Bye 2077snaillazy@gmail.com"))
                 (lambda
                   (msg)
                   (when msg
                     (string-match-p
                      (concat "^/" "2077snaillazy" "/")
                      (mu4e-message-field msg :maildir))))
                 ((user-mail-address . "2077snaillazy@gmail.com")
                  (user-full-name . "Snail Lazy")
                  (mu4e-compose-signature . "")
                  (mu4e-trash-folder . "/2077snaillazy/[Gmail].Trash")
                  (mu4e-sent-folder . "/2077snaillazy/[Gmail].Sent Mail")
                  (mu4e-drafts-folder . "/2077snaillazy/[Gmail].Drafts")
                  (mu4e-maildir-shortcuts
                   ("/2077snaillazy/INBOX" . 105)
                   ("/2077snaillazy/[Gmail].Trash" . 116)
                   ("/2077snaillazy/[Gmail].Sent Mail" . 115)
                   ("/2077snaillazy/[Gmail].Spam" . 83))
                  (smtpmail-queue-dir . "~/.mail/2077snaillazy/queue/cur")
                  (smtpmail-smtp-user . "2077snaillazy")
                  (smtpmail-mail-address . "2077snaillazy@gmail.com")
                  (smtpmail-smtp-server . "smtp.gmail.com")
                  (smtpmail-smtp-service . 587)))
   #s(mu4e-context "L"
                   (lambda nil
                     (mu4e-message "Hello lazysnail2077@gmail.com"))
                   (lambda nil
                     (mu4e-message "Bye lazysnail2077@gmail.com"))
                   (lambda
                     (msg)
                     (when msg
                       (string-match-p
                        (concat "^/" "lazysnail2077" "/")
                        (mu4e-message-field msg :maildir))))
                   ((user-mail-address . "lazysnail2077@gmail.com")
                    (user-full-name . "Lazy Snail")
                    (mu4e-compose-signature . "")
                    (mu4e-trash-folder . "/lazysnail2077/[Gmail].Trash")
                    (mu4e-sent-folder . "/lazysnail2077/[Gmail].Sent Mail")
                    (mu4e-drafts-folder . "/lazysnail2077/[Gmail].Drafts")
                    (mu4e-maildir-shortcuts
                     ("/lazysnail2077/INBOX" . 105)
                     ("/lazysnail2077/[Gmail].Trash" . 116)
                     ("/lazysnail2077/[Gmail].Sent Mail" . 115)
                     ("/lazysnail2077/[Gmail].Spam" . 83))
                    (smtpmail-queue-dir . "~/.mail/lazysnail2077/queue/cur")
                    (smtpmail-smtp-user . "lazysnail2077")
                    (smtpmail-mail-address . "lazysnail2077@gmail.com")
                    (smtpmail-smtp-server . "smtp.gmail.com")
                    (smtpmail-smtp-service . 587))))
#+end_src

**** add faces to the accounts in the header view :week2:

Freely readapted from [[https://emacs.stackexchange.com/questions/26913/coloring-mu4e-headers-based-on-title-content#50708][coloring-mu4e-headers-based-on-title-content]].

colors can be introspected with ~list-colors-display~

#+begin_src emacs-lisp :results silent
(defvar mu4e-accounts-colors
  '(("lazysnail2077@gmail.com" . "green")
    ("2077snaillazy@gmail.com" . "red")))

(defun mu4e-headers-line-apply-accounts-face (msg line)
  "Apply a foreground face to the header in function of
`mu4e-accounts-colors'."
  ;; loop over the fields
  ;; so it distincts also
  ;; our own accounts if
  ;; ever we send a mail
  ;; between them
  (let ((fields '(:from :to :cc :bcc)))
    (catch 'found
      (dolist (field fields)
        ;; found the face
        (dolist (account mu4e-accounts-colors)
          (when (mu4e-message-contact-field-matches
                 msg field
                 (car account))
            (add-face-text-property
             0 (length line)
             `(:foreground ,(cdr account))
             t line)
            (throw 'found t)))))
    ;; always returns the line
    line))

(add-to-list 'mu4e~headers-line-handler-functions
             'mu4e-headers-line-apply-accounts-face)
#+end_src

*** refile policy :week2:

[[info:(info "(mu4e) Smart refiling")][From the mu4e manual]]

The nice thing about the refile policy of mu4e is, it done in elisp and by a function you have full access to, so we can filter on the headers of the mail, content, or whatever is available at runtime.

#+begin_src
(setq mu4e-refile-folder
       (lambda (msg)
         (cond
           ;; messages to the mu mailing list go to the /mu folder
           ((mu4e-message-contact-field-matches msg :to
              "mu-discuss@googlegroups.com")
             "/mu")
           ;; messages sent directly to some spefic address me go to /private
           ((mu4e-message-contact-field-matches msg :to "me@example.com")
             "/private")
           ;; messages with football or soccer in the subject go to /football
           ((string-match "football\\|soccer"
              (mu4e-message-field msg :subject))
             "/football")
           ;; messages sent by me go to the sent folder
           ((mu4e-message-sent-by-me msg
              (mu4e-personal-addresses))
             mu4e-sent-folder)
           ;; everything else goes to /archive
           ;; important to have a catch-all at the end!
           (t  "/archive"))))
#+end_src

*** debugging your setup :week4:

In all the settings specified something may have gone wrong. Hopefully you have figured out what with the logs of your IMAP client but what if it is the SMTP that have an issue ?

You can activate logs for that with :
#+begin_src emacs-lisp
(setq smtp-debug-information t)
(setq smtp-debug-verbose t)
#+end_src

~mu4e~ have also some settings you can activate with :
#+begin_src emacs-lisp
(mu4e-toggle-logging)
#+end_src
Then consult with:
#+begin_src emacs-lisp
(mu4e-show-log)
#+end_src

With the mu4e contexts, you may have some settings that are not set accordingly when switching contexts, the way to inspect them is simply to inspect the =smtpmail-*= variables.

eg, when switching context, is the =smtpmail-smtp-user= set to the new context ? Look at it with =C-h a=.

** facilitate code navigation inside emacs

#+CAPTION: with defaults settings, read may code become difficult.
[[file:Emacs_1.png]]

Continue wrapped words at whitespace, rather than in the middle of a word.

#+begin_src emacs-lisp
(setq-default word-wrap t)
#+end_src

Does not wrap by default in prog-mode the reasonning is, in several prog-mode, having emacs displaying the same line on multiple lines is confusing.
eg: a comment. comments usually start with an identifier like ;; for elisp so you have extra effort to understand what are the commented lines or not.

Also indentation may be critical and again, filling the lines doesn't help to understand or worse and may be dangerous for the soft, eg: python

On the other hand, in all others cases, displaying multiples lines when needed to fit visually a single line, actually helps a lot to the readability. Even in non text-mode; think trying to read an error log from a shell output. Reading error logs is already not an agreeable experience but if you have to scroll horizontally for each line that is worse. Fortunately, the interactive shell is not a prog-mode.

Finally when you cannot select the buffer displaying the infos, you *need* to emacs to display the multilines, otherwise you never read the line ! That is the case when, eg, a function uses a read command.
#+begin_src emacs-lisp
(defun pils-truncate-lines ()
  (setq truncate-lines t))

(add-hook 'prog-mode-hook #'pils-truncate-lines)
(add-hook 'text-mode-hook #'pils-truncate-lines)
#+end_src

If enabled (and `truncate-lines' was disabled), soft wrapping no longer occurs when that window is less than `truncate-partial-width-windows' characters wide. We don't need this, and it's extra work for Emacs otherwise, so off it goes.

#+begin_src emacs-lisp
(setq truncate-partial-width-windows nil)
#+end_src

Activate the ~visual-line-mode~ in all mode derived from the ~text-mode~.

#+begin_src emacs-lisp
(add-hook 'text-mode-hook #'visual-line-mode)
#+end_src

Using elec-pair (built-in) we can easily wrap expression in parenthesis.

#+begin_src emacs-lisp
(use-package elec-pair
    :ensure nil
    :config
    (electric-pair-mode 1))
#+end_src

~rainbow-delimiters~ add colors to the parenthesis in function of their depth, there is also a built-in mode, show-paren-mode, that match the pair of parens at point so we can use it to emphasize them.

#+begin_src emacs-lisp
(use-package rainbow-delimiters)

(setq show-paren-when-point-inside-paren t
      show-paren-when-point-in-periphery t)
(show-paren-mode t)

(set-face-attribute 'show-paren-match nil
 		      :strike-through t
		      :underline nil
		      :weight 'ultra-bold)
#+end_src

The Protesilaos Stavrou's themes are nice and well thought, they focus on choosing the colors with the better contrast to achieve the better accessibility ; I highly recommends them.

#+begin_src emacs-lisp
(use-package modus-themes
  :config
  (load-theme 'modus-vivendi)
  (set-face-attribute 'default nil :height 800))
#+end_src


Next are not so related but IMHO nice.

no tabs.
#+begin_src emacs-lisp
(set-default 'indent-tabs-mode nil)
#+end_src

yanking on top of a selection, replace the selection.
#+begin_src emacs-lisp
(delete-selection-mode 1)
#+end_src

#+CAPTION: with truncated lines, we have to navigate but it may be less confusing anyway.
[[file:Emacs_2.png]]

*** hydra comes to help :week2:

~hydra~ is a popular package that can enhance the emacs interface by increasing the visibility of keybindings and allowing to define different type of behavior for the keys.
It especially shine when for the keymaps containing repetitive commands such as the rectangle selection one :

Here I define pink ‘heads’, that will
 1. not exit the hydra when called,
 2. still allow others external commands to be performed.

#+begin_src emacs-lisp
 (define-key ctl-x-map (kbd "<SPC>")
  (defhydra hydra-rectangle (:body-pre (progn (rectangle-mark-mode 1))
                             :color pink
                             :hint nil
                             :post (deactivate-mark))
    "
  ^^_i_^^   _w_:copy _o_pen  ^_N_ums _u_ndo
_j_ _k_ _l_ _y_ank   _t_ype  ^^_s_wap-points
 _q_uit^^^^ _d_:kill _c_lear _r_eset _R_egister"
    ("i" rectangle-previous-line)
    ("k" rectangle-next-line)
    ("j" rectangle-backward-char)
    ("l" rectangle-forward-char)
    ("d" kill-rectangle)                    ; C-x r k
    ("y" yank-rectangle)                    ; C-x r y
    ("w" copy-rectangle-as-kill)            ; C-x r M-w
    ("o" open-rectangle)                    ; C-x r o
    ("t" string-rectangle)                  ; C-x r t
    ("c" clear-rectangle)                   ; C-x r c
    ("s" rectangle-exchange-point-and-mark) ; C-x C-x
    ("N" rectangle-number-lines)            ; C-x r N
    ("r" (if (region-active-p)
             (deactivate-mark)
           (rectangle-mark-mode 1)))
    ("R" copy-rectangle-to-register)        ; C-x r r
    ("u" undo nil)
    ("q" nil)))
#+end_src

It can be used also to simply enhance the visibility of some hard to remember commands :

The blue ‘head’ is the classical behavior : call the command once and exit the hydra.

#+begin_src emacs-lisp
(define-key help-map "a"
  (defhydra hydra-apropos (:color blue :hint nil)
    "
⸤_a_⸣propos \
◆ ⸤_c_⸣ommand \
◆ ⸤_d_⸣docs
valu⸤_e_⸣ \
◆ ⸤_l_⸣ibrary \
◆ ⸤_u_⸣ser option
⸤_v_⸣ariable \
◆ ⸤_i_⸣nfo \
◆ ⸤_t_⸣ags
local valu⸤_E_⸣ \
◆ local ⸤_V_⸣ar \
◇ ⸤_q_⸣uit"
    ("a" apropos)
    ("c" apropos-command)
    ("d" apropos-documentation)
    ("e" apropos-value)
    ("l" apropos-library)
    ("u" apropos-user-option)
    ("v" apropos-variable)
    ("i" info-apropos)
    ("t" xref-find-apropos)
    ("E" apropos-local-value)
    ("V" apropos-local-variable)
    ("q" nil)))
#+end_src

For this last example, it is an hydra meant to help to understand the sexp navigation of emacs, the commands keeps the letters they have in the global-map, but are more accessible and visible.

#+begin_src emacs-lisp
(global-set-key (kbd "<f6>")
  (defhydra hydra-rectangle (:color pink
                             :hint nil)
    "
_u_p   _a_:beg _p_rev _e_nd  _h_:m.def _t_ranspose
_d_own _b_ack  _n_ext _f_orw _SPC_:m.sexp _q_uit
_k_ill _c_heck _r_aiz _D_:nar.def _w_iden
"
    ("u" backward-up-list)
    ("d" down-list)
    ("a" beginning-of-defun)
    ("p" backward-list)
    ("e" end-of-defun)
    ("b" backward-sexp)
    ("n" forward-list)
    ("f" forward-sexp)
    ("h" mark-defun)
    ("SPC" mark-sexp)
    ("t" transpose-sexp)
    ("k" kill-sexp)
    ("c" check-parens)
    ("r" raise-sexp)
    ("D" narrow-to-defun)
    ("w" widen)
    ("q" nil)))
#+end_src

*** a custom mode-line element :week2:

While looking at these settings I thought it may help to know the level of depth of the point at any moment since we can rarely rely on seeing the whole expression.

I created a quick prototype to get the depth of the parenthesis. I should probably use ~scan-lists~ directly instead of ~up-list~.

Note that version will only work on emacs 27, to get it working on emacs 28, one should replace

(scan-error (throw 'depth depth))))

by

(user-error (throw 'depth depth))))

#+begin_src emacs-lisp
(defun pils/list-depth ()
  "Count the list depth from point to the top level,
`message' it in interactive calls, update the mode-line otherwise,
in both cases, save the depth in `pils--list-depth-cache'."
  (interactive)
  ;; preserve point and mark-ring
  (save-mark-and-excursion
    (let ((depth 0)
          ;; do not mess with the transient mark
          deactivate-mark)
      (catch 'depth
        ;; check-parens on the boundaries
        (condition-case err
            (check-parens)
          (user-error
           (throw 'depth
             (setq depth ;; with red face
                   (propertize "nil"
                               'font-lock-face
                               '(:foreground "red"))))))
        ;; count the list nesting by
        ;; going to the top sexp by sexp
        (condition-case err
            (while t
              (up-list
               nil
               'escape-string
               'no-syntax-crossing)
              (cl-incf depth))
          ;; the top is an scan-error
          ;; we can release the loop
          (scan-error (throw 'depth depth))))
      ;; eventually test it interactively
      (when (interactive-p)
        (message "list depth: %s" depth))
      ;; update the cache for the modeline
      (setq pils--list-depth-cache depth)
      ;; force a redisplay of the modeline
      (force-mode-line-update))))
#+end_src

Then we want to run this only at quiet pace, so while creating the mode line element, I slow it with a timer and a cache.
#+begin_src
(defvar-local pils--list-depth-cache nil
  "Dummy variable to store the return
value of `pils/list-depth'.")

(defvar pils--list-depth-timer
  (timer-create)
  "Timer to update the list depth
element of the modeline at a
relatively quiet pace.")

(defun pils--modeline-list-depth ()
  "Return the list depth when in
`emacs-lisp-mode', via the timer
`pils--list-depth-timer' every
0.2 seconds."
  (if (memq major-mode '(emacs-lisp-mode
                         lisp-interaction-mode))
      (progn
        (when (not
               (timerp pils--list-depth-timer))
          (setq pils--list-depth-timer
                (run-with-timer
                 0.2 0.2
                 #'pils/list-depth)))
        (format " (%s) " pils--list-depth-cache))
    (when (timerp pils--list-depth-timer)
      (cancel-timer pils--list-depth-timer)
      (setq pils--list-depth-timer nil)
      (setq pils--list-depth-cache nil))
    ""))
#+end_src

Now we can use it in the default mode-line :
#+begin_src

(setq-default
 mode-line-format
 '("%e" mode-line-front-space
   mode-line-mule-info
   mode-line-client
   mode-line-modified
   mode-line-remote
   ;; mode-line-frame-identification
   " "
   ;; buffer identification always claims
   ;; 12 characters, we may revise that
   " "
   mode-line-buffer-identification
   "%l-%c"
   " "
   (:eval (pils--modeline-list-depth))
   " "
   (vc-mode vc-mode)
   " "
   mode-line-modes
   mode-line-misc-info
   mode-line-end-spaces))
#+end_src

** little tips
*** using imenu :week3:

[[elisp:(info "(elisp) Imenu")][~imenu~ is a powerful tool.]]
It can be used with a completion engine to navigate very easily in documents.
With helm, its integrated command it ~helm-imenu~ that is bound to =C-x c i=.

*** org links :week3:

[[elisp:(info "(org) Hyperlinks")][We start to have a lot of org links in this document.]]
I use them often to point to the relevant pages of the Info manuals (and that one of the reasons that it is important to read this file inside Emacs).
To consult them, use =C-c C-o= that runs ~org-open-at-point~.

*** org tags :week3:

I started to tag the org headings to give them a numerated week.
[[elisp:(info "(org) Tags")][Tags can be used in conjunction of ~org-agenda~ & cie for your own purpose.]]
There is an useful command to narrow the view to only some tags ~org-sparse-tree~ that is bound to =C-c /=.

** using git within emacs
*** choosing the right interface :week3:

As we uses git as backend, it needs to be configured with an identity :
#+BEGIN_SRC sh
git config --global user.name "my full name"
git config --global user.email "my.address@somemail.com"
#+END_SRC

Also it may be worthwhile to add this snippet in =~/.bashrc= or =~/.zshrc= to specify to our shell that we want him to uses ~emacsclient~ when, eg, committing changes with git. Since we have already put in the init file (server-start), the server should be running and this should work at expected.

#+begin_src bash
if [ -n "$ZSH_VERSION" ]; then emulate -L sh; fi

if [ -z "${EDITOR}" ] ; then
  export EDITOR='emacsclient'
fi
if [ -n "${EDITOR}" ] && [ -z "${VISUAL}" ] ; then
  export VISUAL="${EDITOR}"
fi
#+end_src

Emacs have natively the vc library and, indeed, Magit is very popular these days.

Magit with its transient interface, is maybe more difficult to apprehend when the instructions does not fit the window and the way to get its binding in a non-transient buffer it to ask for the help of the major mode, or to consult its manual, eg :

_To get help buffer for prefix map of vc_, Start typing =C-x v= then =C-h=

_To get help buffer for the major mode of magit (no prefix map available by default)_, Start typing =C-x g= then =C-h m=.

#+CAPTION: Magit and its transient maps are not the most accessible interface
[[file:Emacs_3.png]]

[[https://github.com/magit/magit/issues/4408][I started an issue at this subject.]]

~vc~ is a library that can be used with many others version control software, not only git, and have less commands for git. [[elisp:(info "(emacs) Version Control")][vc is documented in the emacs manual]], (not the elisp one).

[[https:www.youtube.com/watch?v=0YlYX_UjH5Q&autoplay=0][Protesilaos Stavrou has made a video about it.]]

*** (a bit more involved) integration with the forges

But we may also install the ~forge~ package to get a more complete integration with specific forges as github to being able to eg, make a pull request to a repository and merge one.

#+begin_src emacs-lisp
(use-package forge)
#+end_src

[[https://www.youtube.com/watch?v=fFuf3hExF5w][Zaiste makes a video about it]]

[[https://github.com/settings/tokens/new][We need to go to the tokens settings of our user account to create one]].

Once done we can use this password in the same authinfo file we already created for the mails but this time the parameters will looks like :

#+begin_comment
machine api.github.com login <user-name>^forge password <password>
#+end_comment

No port seems required and ‘forge’ is the application name you previously named when creating the token.

Now we should be able to see pull requests from github and to merge them.

** local variables

# Local Variables:
# org-tags-column: 0
# End:
