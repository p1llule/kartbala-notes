* assisting kartbala in his emacs quest for low vision

This document specify the steps I used to replicate and develop kartabala/emacs. 
It is a live document meant to be read inside emacs (github.com does not display some blocks and other useful information!) 
Some of the org-block are meant to be evaluated in emacs with ﴾ C-c C-c \ (org-ctrl-c-ctrl-c) ﴿, to evaluate sh/bash blocks, ob-shell is required. some are meant to be tangled with ﴾ C-c C-v C-t / (org-babel-tangle) ﴿, a block can be tangled alone by adding an universal-argument ﴾ C-u C-c C-v C-t ﴿.
*Warning : tangling will override any files already present!*

#+begin_src emacs-lisp
(require 'ob-shell)
#+end_src

** mail configuration

So to get mu4e working I used :
 - a imap client (popular choices are offlineimap or isync) to get mails
 - a smtp client (built-in emacs) to send mails
 - a way to specify the authentification (.authinfo.gpg) file
 - a way to protect our authenfification (gpg)

*** .offlineimaprc :week1:
This is a simple offlineimap configuration file, it specifies the accounts, eventually the folders to sync, the passwords and the certificates of the mail provider.

https://stackoverflow.com/questions/24675167/ca-certificates-mac-os-x
It seems there is two ways to get the certificate on macos:
 - or export them from the keychain
 - or install openssl, it will also export them into /usr/local/etc/openssl/cert.pem from the keychain.

The password can be specified in plain text inside this document with a `remotepass = <password>` instead of the `remotepasseval = <pythonfunc(args)>, it is useful to do so when testing the file, once it is done,  I implemented a more secure way to store them.

Gmail have a particular way to rely on labels and this may leads to a massive duplication of emails in your IMAP folder. [[https://mail.google.com/mail/u/0/#settings/labels][Please adjust the labels accordingly]].

#+begin_src conf :tangle ~/.offlineimaprc
[general]
# adjust here the name and number of accounts
accounts = lazysnail2077, 2077snaillazy
maxsyncaccounts = 2
ui=TTYUI
socktimeout = 60
# password management functions
pythonfile = ~/.offlineimap.py

## account 1
[Account lazysnail2077]
localrepository = Local-lazysnail2077
remoterepository = Remote-lazysnail2077

[Repository Local-lazysnail2077]
type = Maildir
localfolders = ~/.mail/lazysnail2077

[Repository Remote-lazysnail2077]
type = Gmail
remotehost = imap.gmail.com
remoteuser = lazysnail2077@gmail.com
remotepasseval = get_password_emacs("imap.gmail.com", "lazysnail2077@gmail.com", "993")
ssl = yes
sslcacertfile = /etc/ssl/certs/ca-certificates.crt
maxconnections = 2
# folder(s)? to exclude
# All Mail seems to be a constant source of duplicates
folderfilter = lambda foldername: foldername not in ['[Gmail]/All Mail']

## account 2
[Account 2077snaillazy]
localrepository = Local-2077snaillazy
remoterepository = Remote-2077snaillazy

[Repository Local-2077snaillazy]
type = Maildir
localfolders = ~/.mail/2077snaillazy

[Repository Remote-2077snaillazy]
type = Gmail
remotehost = imap.gmail.com
remoteuser = 2077snaillazy@gmail.com
remotepasseval = get_password_emacs("imap.gmail.com", "2077snaillazy@gmail.com", "993")
ssl = yes
sslcacertfile = /etc/ssl/certs/ca-certificates.crt
maxconnections = 2
folderfilter = lambda foldername: foldername not in ['[Gmail]/All Mail']
#+end_src

*** gpg key
Since I rely on encryption to secure my credentials; here a simple memo :

**** creation :week1:
the simplest way get a pair of gpg key is to create them interactively in a terminal:
#+begin_src bash :eval no
gpg2 --full-generate-key
#+end_src

And that is pretty all with gpg alone, now we can uses this key inside emacs and with other softwares.

Unfortunately maybe your terminal or emacs is not able on your computer to use your graphical server to ask passwords, so you may need to create a key in batch mode instead :

#+begin_src bash :results pp
# temporary prevent history
unset HISTFILE
# comment the next line to make a durable key
export GNUPGHOME="$(mktemp -d)"
# create a specification file in /tmp/crypto
cat > /tmp/crypto <<EOF
     %echo Generating a basic OpenPGP key
     Key-Type: default
     Key-Length: 4096
     Subkey-Type: default
     Subkey-Length: 4096
     Name-Real: John Duh
     Name-Comment: eventually
     Name-Email: mymail@gmail.com.
     Expire-Date: 0
     Passphrase: very-secure-password
     %commit
     %echo done
EOF
# redirection only to get the output in org-mode
2<&1 gpg --batch --generate-key /tmp/crypto
# clear your traces.
rm /tmp/crypto
#+end_src

#+RESULTS:
: gpg: keybox '/tmp/tmp.UdBqBAWACV/pubring.kbx' created
: gpg: Generating a basic OpenPGP key
: gpg: /tmp/tmp.UdBqBAWACV/trustdb.gpg: trustdb created
: gpg: key D084633A29F0D54E marked as ultimately trusted
: gpg: directory '/tmp/tmp.UdBqBAWACV/openpgp-revocs.d' created
: gpg: revocation certificate stored as '/tmp/tmp.UdBqBAWACV/openpgp-revocs.d/F3D6DE5627A10F4D8CDAE84CD084633A29F0D54E.rev'
: gpg: done

**** (optional) sharing our id :week1:
now eventually we can declare ourselves to keyservers. This may be helpful for eg signing a FSF assessment.

first check our fingerprint :
#+begin_src bash :results pp
gpg --fingerprint lazysnail2077@gmail.com
#+end_src

#+RESULTS:
: pub   rsa4096 2021-05-28 [SC]
:       E9AF 49C4 6F8E AE92 139D  F319 4814 7806 2064 2A11
: uid           [ultimate] Lazy Snail <lazysnail2077@gmail.com>
: sub   rsa4096 2021-05-28 [E]
:

E9AF 49C4 6F8E AE92 139D  F319 4814 7806 2064 2A11
is the fingerprint,
4814 7806 2064 2A11
is the long key id
2064 2A11
is the short key id

So finally we can send it to the keyservers of our choice :
#+begin_src bash
gpg2 --keyserver keys.gnupg.net --search "20642A11"
#+end_src

and verify it worked :
#+begin_src bash
gpg2 --keyserver keys.gnupg.net --search "20642A11"
#+end_src

the server should return the mail address we initially specified.

**** (optional) going beyond :week1:
This setup may be enhanced by creating a signing subkey and keeping our master key and revocation certificate in, eg a cold storage.
https://alexcabal.com/creating-the-perfect-gpg-keypair

*** authinfo :week1:
[[elisp:(info "(auth) Help for users")][authinfo manual]]
By creating this file as =~/.authinfo.gpg= with emacs, emacs will automatically recognize it is an encrypted file and ask you which gpg key you wish to use when needed.
The format of netrc|authinfo file is quite simple when we get it:
#+begin_example
machine imap.gmail.com port 993 login this.is@mail.net password very-secure-password
machine smtp.gmail.com port 587 login this.is@mail.net password very-secure-password
machine imap.gmail.com port 993 login another@mail.net password very-much-secure-password
machine smtp.gmail.com port 587 login another@mail.net password very-much-secure-password
#+end_example

*** .offlineimap.py :week1:
This setup imply to start emacs as a server with emacsclient:

To start an emacsclient session, you can type in a terminal `emacsclient -c -a ""`, or use ~server-start~ from inside an emacs session.
To kill the server and emacs I can use `pkill emacs`.

credits to https://www.emacswiki.org/emacs/OfflineIMAP with little modifications:
#+begin_src python :tangle "~/.offlineimap.py" :shebang "#!/bin/python"
  import subprocess
  def get_output(cmd):
  # Bunch of boilerplate to catch the output of a command:
	pipe = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
	(output, errout) = pipe.communicate()
	assert pipe.returncode == 0 and not errout
	return output
  def get_password_emacs(host, user, port):
	cmd = "emacsclient --eval '(offlineimap-get-password \"%s\" \"%s\" \"%s\")'" % (host,user,port)
	return get_output(cmd).strip().lstrip('"').rstrip('"')
#+end_src

*** offlineimap-get-password :week1:
From the offlineimap documentation :
#+begin_quote
#    If a matching entry is found in ~/.netrc (see netrc (5) for
#    information) this password will be used. Do note that netrc only
#    allows one entry per hostname.
#+end_quote
I realized nor the original script of emacswiki nor the offlineimap mechanism would cut it. They are designed to get only one user per machine/port, or force you to use multiple files, this is not what I wanted, and we may have multiple accounts from the same machine/port.
Thankfully to ~netrc.el~, the solution can be abstracted without too much boilerplate:
#+begin_src emacs-lisp :results pp
  (defun offlineimap-get-password (machine user port)
    "Get the password of a .netrc file from its MACHINE, USER, PORT."
    (require 'netrc)
    (let* ((netrc (netrc-parse
		   (expand-file-name "~/.authinfo.gpg")))
	   credentials password)
      (catch 'password
	(dolist (credentials netrc)
	  (when (netrc-machine (list credentials) machine)
	    (dolist (lst credentials)
	      (when (and (string= (cdr (assoc "login" credentials)) user)
			 (string= (cdr (assoc "port" credentials)) port))
		(throw 'password (cdr (assoc "password" credentials))))))))))

  (offlineimap-get-password "imap.gmail.com" "lazysnail2077@gmail.com" "993")
#+end_src

*** pittfalls :week1:

 - activate IMAP in the gmail settings
 - authorize "the less trusted applications"
 - disconnect
 - reconnect and validate in the security logs that's me who authorized the previous step.
 - It may be necessary to go to a page validing a captcha ???

It may not work yet and nobody will reliably tell you why. take a tea.
then try to authenticate again with your IMAP client :

Make a dry run to test the setup and eventually get the informations about your mail folders:

#+begin_src sh
offlineimap --dry-run
#+end_src

~offlineimap~ will throw errors with --dry-run when it is not initialized.
This is a known bug, confusing, but known.
So when using --dry-run to see the mailboxes creations with your =.offlineimaprc= settings, keep this in mind.

*Always backup your local mailboxes before implementing new configurations!*

*** initialize mu :week1:

Once the IMAP client is setup, we can initialize mu.
#+begin_src sh
mu init --maildir ~/.mail              \
  --my-address=2077snaillazy@gmail.com \
  --my-address=lazysnail2077@gmail.com
mu index
#+end_src

*** contexts :week1:

mu4e allow to have multiple mail adress in the same setup. It is a good idea to defines these settings in a separate file from your main emacs configuration so it can be easily ignored by git with the =.gitignore= file, eg in ~user-emacs-directory~ =./personal/mu4e-contexts.el=

I done it as a template. You can modify the top variables with your personal informations and they will be inlined at the appropriate place. You will also like to put your own signature, and to change the directory names with the ones appropriate for your mail provider. To declare more accounts, declare new top variables and add new ~make-mu4e-context~ expressions for them in the list.


TODO: review this match function for a more simple use with

(string-prefix-p "/gmail" (mu4e-message-field msg :maildir)

#+begin_src emacs-lisp :eval no  :tangle (concat  user-emacs-directory "personal/mu4e-contexts.el")
(let* ((name1 "lazysnail2077")
       (address1 (concat name1 "@gmail.com"))
       (fullname1 "Lazy Snail")
       (name2 "2077snaillazy")
       (address2 (concat name2 "@gmail.com"))
       (fullname2 "Snail Lazy "))
;; a backquote with eval are used here to allow
;; inline expressions prefixed with a comma
  (eval
   `(progn
;; * default value
      (customize-set-variable 'user-mail-address address1)
;; * contexts
      (setq mu4e-contexts
;; ** 1 account
            (list
             (make-mu4e-context
              :name ,fullname1
              :enter-func (lambda ()
                            (mu4e-message "Hello world."))
;; this function change context by matching
;; any mail that contact address1
;; or uses one of its folders.
;; this is quite agressive and the
;; second part must be yet more tested
              :match-func (lambda (msg)
                            (or
                             (when msg
                               (mu4e-message-contact-field-matches
                                msg '(:from :to :cc :bcc)
                                ,address1))
                             (when-let ((msg (mu4e-message-at-point 'no-error)))
                               (string-match-p
                                (concat "^/" ,name1 "/")
                                (mu4e-message-field msg :maildir)))))
              :vars '((user-mail-address . ,address1)
                      (user-full-name . ,fullname1)
                      (mu4e-compose-signature
                       . "A snail is, in loose terms,
a shelled gastropod.\n")
;; *** 1 inbox settings
;; initialise the folders otherwise
;; it will uses and creates defaults ones
                      (mu4e-trash-folder
                       . ,(concat "/" name1
                                  "/[Gmail].Trash"))
                      (mu4e-sent-folder
                       . ,(concat "/" name1
                                  "/[Gmail].Sent Mail"))
                      (mu4e-drafts-folder
                       . ,(concat "/" name1
                                  "/[Gmail].Drafts"))
                      (mu4e-maildir-shortcuts
                       . ((,(concat "/" name1 "/INBOX") . ?i)
                          (,(concat "/" name1 "/[Gmail].Trash") . ?t)
                          (,(concat "/" name1 "/[Gmail].Sent Mail") . ?s)
                          (,(concat "/" name1 "/[Gmail].Spam") . ?S)))
;; *** 1 smtp configuration
                      (smtpmail-queue-dir
                       . ,(concat "~/.mail/" name1 "/queue/cur"))
                      (smtpmail-smtp-user . ,name1)
                      (smtpmail-smtp-server . "smtp.gmail.com")
                      (smtpmail-smtp-service . 587)))
;; ** 2 account
             (make-mu4e-context
              :name ,fullname2
              :enter-func (lambda ()
                            (mu4e-message "Hello there"))
              :match-func (lambda (msg)
                            (or
                             (when msg
                               (mu4e-message-contact-field-matches
                                msg '(:from :to :cc :bcc) ,address2))
                             (when-let ((msg (mu4e-message-at-point 'no-error)))
                               (string-match-p
                                (concat "^/" ,name2 "/")
                                (mu4e-message-field msg :maildir)))))
              :vars '((user-mail-address . ,address2)
                      (user-full-name . ,fullname2)
                      (mu4e-compose-signature
                       . "Snails feed at night,
and they have teeths!")
;; *** 2 inbox settings
;; initialise the folders otherwise
;; it will uses defaults ones
                      (mu4e-trash-folder
                       . ,(concat "/" name2 "/[Gmail].Trash"))
                      (mu4e-sent-folder
                       . ,(concat "/" name2 "/[Gmail].Sent Mail"))
                      (mu4e-drafts-folder
                       . ,(concat "/" name2 "/[Gmail].Drafts"))
                      (mu4e-maildir-shortcuts
                       . ((,(concat "/" name2 "/INBOX") . ?i)
                          (,(concat "/" name2 "/[Gmail].Trash") . ?t)
                          (,(concat "/" name2 "/[Gmail].Sent Mail") . ?s)
                          (,(concat "/" name2 "/[Gmail].Spam") . ?S)))
                      (smtpmail-queue-dir
                       . ,(concat "~/.mail/" name2 "/queue/cur"))
;; *** 2 smtp configuration
                      (smtpmail-smtp-user . ,name2)
                      (smtpmail-smtp-server . "smtp.gmail.com")
                      (smtpmail-smtp-service . 587))))))))

;; * end
(provide 'mu4e-contexts.el)
#+end_src

Once all these prerequisite are fulfilled, and mu4e is correctly configured in your emacs configuration, now you should have a mu4e working with multiple mail accounts ! \o/

TODO: refine the gmail integration.

Do we need to set (setq mu4e-sent-messages-behavior 'delete) ?

*** add faces to the accounts in the header view :week2:

Freely readapted from [[https://emacs.stackexchange.com/questions/26913/coloring-mu4e-headers-based-on-title-content#50708][coloring-mu4e-headers-based-on-title-content]].

colors can be introspected with ~list-colors-display~

#+begin_src emacs-lisp
(defvar mu4e-accounts-colors
  '(("lazysnail2077@gmail.com" . "green")
    ("2077snaillazy@gmail.com" . "red")))

(defun mu4e-headers-line-apply-accounts-face (msg line)
  "Apply a foreground face to the header in function of
`mu4e-accounts-colors'."
  ;; loop over the fields
  ;; so it distincts also
  ;; our own accounts if
  ;; ever we send a mail
  ;; between them
  (let ((fields '(:from :to :cc :bcc)))
    (catch 'found
      (dolist (field fields)
        ;; found the face
        (dolist (account mu4e-accounts-colors)
          (when (mu4e-message-contact-field-matches
                 msg field
                 (car account))
            (add-face-text-property
             0 (length line)
             `(:foreground ,(cdr account))
             t line)
            (throw 'found t)))))
    ;; always returns the line
    line))

(add-to-list 'mu4e~headers-line-handler-functions
             'mu4e-headers-line-apply-accounts-face)
#+end_src

*** refile policy :week2:

[[info:(info "(mu4e) Smart refiling")][From the mu4e manual]]

The nice thing about the refile policy of mu4e is, it done in elisp and by a function you have full access to, so we can filter on the headers of the mail, content, or whatever is available at runtime.

#+begin_src
(setq mu4e-refile-folder
       (lambda (msg)
         (cond
           ;; messages to the mu mailing list go to the /mu folder
           ((mu4e-message-contact-field-matches msg :to
              "mu-discuss@googlegroups.com")
             "/mu")
           ;; messages sent directly to some spefic address me go to /private
           ((mu4e-message-contact-field-matches msg :to "me@example.com")
             "/private")
           ;; messages with football or soccer in the subject go to /football
           ((string-match "football\\|soccer"
              (mu4e-message-field msg :subject))
             "/football")
           ;; messages sent by me go to the sent folder
           ((mu4e-message-sent-by-me msg
              (mu4e-personal-addresses))
             mu4e-sent-folder)
           ;; everything else goes to /archive
           ;; important to have a catch-all at the end!
           (t  "/archive"))))
#+end_src

** facilitate code navigation inside emacs

#+CAPTION: with defaults settings, read may code become difficult.
[[file:Emacs_1.png]]

Continue wrapped words at whitespace, rather than in the middle of a word.

#+begin_src emacs-lisp
(setq-default word-wrap t)
#+end_src

...but don't do any wrapping by default. It's expensive. Enable ~visual-line-mode~ if you want soft line-wrapping. ~auto-fill-mode~ for hard line-wrapping.

#+begin_src emacs-lisp
(setq-default truncate-lines t)
#+end_src

 If enabled (and `truncate-lines' was disabled), soft wrapping no longer occurs when that window is less than `truncate-partial-width-windows' characters wide. We don't need this, and it's extra work for Emacs otherwise, so off it goes.

#+begin_src emacs-lisp
(setq truncate-partial-width-windows nil)
#+end_src

Activate the visual-line-mode in all mode derived from the major-mode text-mode.

#+begin_src emacs-lisp
(add-hook 'text-mode-hook #'visual-line-mode)
#+end_src

Using elec-pair (built-in) we can easily wrap expression in parenthesis.

#+begin_src emacs-lisp
(use-package elec-pair
    :ensure nil
    :config
    (electric-pair-mode 1))
#+end_src

~rainbow-delimiters~ add colors to the parenthesis in function of their depth, there is also a built-in mode, show-paren-mode, that match the pair of parens at point so we can use it to emphasize them.

#+begin_src emacs-lisp
(use-package rainbow-delimiters)

(setq show-paren-when-point-inside-paren t
      show-paren-when-point-in-periphery t)
(show-paren-mode t)

(set-face-attribute 'show-paren-match nil
 		      :strike-through t
		      :underline nil
		      :weight 'ultra-bold)
#+end_src

The Protesilaos Stavrou's themes are nice and well thought, they focus on choosing the colors with the better contrast to achieve the better accessibility ; I highly recommends them.

#+begin_src emacs-lisp
(use-package modus-themes
  :config
  (load-theme 'modus-vivendi)
  (set-face-attribute 'default nil :height 800))
#+end_src


Next are not so related but IMHO nice.

no tabs.
#+begin_src emacs-lisp
(set-default 'indent-tabs-mode nil)
#+end_src

yanking on top of a selection, replace the selection.
#+begin_src emacs-lisp
(delete-selection-mode 1)
#+end_src

#+CAPTION: with truncated lines, we have to navigate but it may be less confusing anyway.
[[file:Emacs_2.png]]

*** hydra comes to help :week2:

~hydra~ is a popular package that can enhance the emacs interface by increasing the visibility of keybindings and allowing to define different type of behavior for the keys.
It especially shine when for the keymaps containing repetitive commands such as the rectangle selection one :

Here I define pink ‘heads’, that will
 1. not exit the hydra when called,
 2. still allow others external commands to be performed.

#+begin_src emacs-lisp
 (define-key ctl-x-map (kbd "<SPC>")
  (defhydra hydra-rectangle (:body-pre (progn (rectangle-mark-mode 1))
                             :color pink
                             :hint nil
                             :post (deactivate-mark))
    "
  ^^_i_^^   _w_:copy _o_pen  ^_N_ums _u_ndo
_j_ _k_ _l_ _y_ank   _t_ype  ^^_s_wap-points
 _q_uit^^^^ _d_:kill _c_lear _r_eset _R_egister"
    ("i" rectangle-previous-line)
    ("k" rectangle-next-line)
    ("j" rectangle-backward-char)
    ("l" rectangle-forward-char)
    ("d" kill-rectangle)                    ; C-x r k
    ("y" yank-rectangle)                    ; C-x r y
    ("w" copy-rectangle-as-kill)            ; C-x r M-w
    ("o" open-rectangle)                    ; C-x r o
    ("t" string-rectangle)                  ; C-x r t
    ("c" clear-rectangle)                   ; C-x r c
    ("s" rectangle-exchange-point-and-mark) ; C-x C-x
    ("N" rectangle-number-lines)            ; C-x r N
    ("r" (if (region-active-p)
             (deactivate-mark)
           (rectangle-mark-mode 1)))
    ("R" copy-rectangle-to-register)        ; C-x r r
    ("u" undo nil)
    ("q" nil)))
#+end_src

It can be used also to simply enhance the visibility of some hard to remember commands :

The blue ‘head’ is the classical behavior : call the command once and exit the hydra.

#+begin_src emacs-lisp
(define-key help-map "a"
  (defhydra hydra-apropos (:color blue :hint nil)
    "
⸤_a_⸣propos \
◆ ⸤_c_⸣ommand \
◆ ⸤_d_⸣docs
valu⸤_e_⸣ \
◆ ⸤_l_⸣ibrary \
◆ ⸤_u_⸣ser option
⸤_v_⸣ariable \
◆ ⸤_i_⸣nfo \
◆ ⸤_t_⸣ags
local valu⸤_E_⸣ \
◆ local ⸤_V_⸣ar \
◇ ⸤_q_⸣uit"
    ("a" apropos)
    ("c" apropos-command)
    ("d" apropos-documentation)
    ("e" apropos-value)
    ("l" apropos-library)
    ("u" apropos-user-option)
    ("v" apropos-variable)
    ("i" info-apropos)
    ("t" xref-find-apropos)
    ("E" apropos-local-value)
    ("V" apropos-local-variable)
    ("q" nil)))
#+end_src

For this last example, it is an hydra meant to help to understand the sexp navigation of emacs, the commands keeps the letters they have in the global-map, but are more accessible and visible.

#+begin_src emacs-lisp
(global-set-key (kbd "<f6>")
  (defhydra hydra-rectangle (:color pink
                             :hint nil)
    "
_u_p   _a_:beg _p_rev _e_nd  _h_:m.def _t_ranspose
_d_own _b_ack  _n_ext _f_orw _SPC_:m.sexp _q_uit
_k_ill _c_heck _r_aiz _D_:nar.def _w_iden
"
    ("u" backward-up-list)
    ("d" down-list)
    ("a" beginning-of-defun)
    ("p" backward-list)
    ("e" end-of-defun)
    ("b" backward-sexp)
    ("n" forward-list)
    ("f" forward-sexp)
    ("h" mark-defun)
    ("SPC" mark-sexp)
    ("t" transpose-sexp)
    ("k" kill-sexp)
    ("c" check-parens)
    ("r" raise-sexp)
    ("D" narrow-to-defun)
    ("w" widen)
    ("q" nil)))
#+end_src

*** a custom mode-line element :week2:

While looking at these settings I thought it may help to know the level of depth of the point at any moment since we can rarely see the whole expression.

First I must backport the ~up-list~ of emacs 28 since I use it especially :
#+begin_src emacs-lisp
;; backporting the version 28 of up-list
(defun pils-up-list_28 (&optional arg escape-strings no-syntax-crossing)
  "Move forward out of one level of parentheses.
This command will also work on other parentheses-like expressions
defined by the current language mode.  With ARG, do this that
many times.  A negative argument means move backward but still to
a less deep spot.  If ESCAPE-STRINGS is non-nil (as it is
interactively), move out of enclosing strings as well.  If
NO-SYNTAX-CROSSING is non-nil (as it is interactively), prefer to
break out of any enclosing string instead of moving to the start
of a list broken across multiple strings.  On error, location of
point is unspecified."
  (interactive "^p\nd\nd")
  (or arg (setq arg 1))
  (let ((inc (if (> arg 0) 1 -1))
        (pos nil))
    (while (/= arg 0)
      (condition-case err
          (save-restriction
            ;; If we've been asked not to cross string boundaries
            ;; and we're inside a string, narrow to that string so
            ;; that scan-lists doesn't find a match in a different
            ;; string.
            (when no-syntax-crossing
              (let* ((syntax (syntax-ppss))
                     (string-comment-start (nth 8 syntax)))
                (when string-comment-start
                  (save-excursion
                    (goto-char string-comment-start)
                    (narrow-to-region
                     (point)
                     (if (nth 3 syntax) ; in string
                         (condition-case nil
                             (progn (forward-sexp) (point))
                           (scan-error (point-max)))
                       (forward-comment 1)
                       (point)))))))
            (if (null forward-sexp-function)
                (goto-char (or (scan-lists (point) inc 1)
                               (buffer-end arg)))
              (condition-case err
                  (while (progn (setq pos (point))
                                (forward-sexp inc)
                                (/= (point) pos)))
                (scan-error (goto-char (nth (if (> arg 0) 3 2) err))))
              (if (= (point) pos)
                  (signal 'scan-error
                          (list "Unbalanced parentheses" (point) (point))))))
        (scan-error
         (let ((syntax nil))
           (or
            ;; If we bumped up against the end of a list, see whether
            ;; we're inside a string: if so, just go to the beginning
            ;; or end of that string.
            (and escape-strings
                 (or syntax (setf syntax (syntax-ppss)))
                 (nth 3 syntax)
                 (goto-char (nth 8 syntax))
                 (progn (when (> inc 0)
                          (forward-sexp))
                        t))
            ;; If we narrowed to a comment above and failed to escape
            ;; it, the error might be our fault, not an indication
            ;; that we're out of syntax.  Try again from beginning or
            ;; end of the comment.
            (and no-syntax-crossing
                 (or syntax (setf syntax (syntax-ppss)))
                 (nth 4 syntax)
                 (goto-char (nth 8 syntax))
                 (or (< inc 0)
                     (forward-comment 1))
                 (setf arg (+ arg inc)))
            (if no-syntax-crossing
                ;; Assume called interactively; don't signal an error.
                (user-error "At top level")
              (signal (car err) (cdr err)))))))
      (setq arg (- arg inc)))))
#+end_src

Next I created a quick prototype to get the depth of the parenthesis. I should probably use ~scan-lists or something instead of ~up-list~...
#+begin_src emacs-lisp
(defun pils/list-depth ()
  "Count the list depth from point to the top level,
`message' it in interactive calls, update the mode-line otherwise,
in both cases, save the depth in `pils--list-depth-cache'."
  (interactive)
  (save-mark-and-excursion
    (let ((depth 0)
          (bounds (bounds-of-thing-at-point 'defun))
          deactivate-mark
          check-parens)
      (catch 'depth

        (condition-case err
            (when bounds
              (scan-sexps (car bounds) (cdr bounds)))
          (scan-error (throw 'depth (setq depth nil))))

        (condition-case err
            (while t
              (pils-up-list_28 nil 'escape-string 'no-syntax-crossing)
              (cl-incf depth))
          (user-error (throw 'depth depth))))

      (when (interactive-p)
        (message "list depth: %s" depth))
      (setq pils--list-depth-cache depth)
      (force-mode-line-update))))
#+end_src

Then we want to run this only at quiet pace, so while creating the mode line element, I slow it with a timer and a cache.
#+begin_src
(defvar-local pils--list-depth-cache nil
  "Dummy variable to store the return
value of `pils/list-depth'.")

(defvar pils--list-depth-timer
  (timer-create)
  "Timer to update the list depth
element of the modeline at a
relatively quiet pace.")

(defun pils--modeline-list-depth ()
  "Return the list depth when in
`emacs-lisp-mode', via the timer
`pils--list-depth-timer' every
0.2 seconds."
  (if (memq major-mode '(emacs-lisp-mode
                         lisp-interaction-mode))
      (progn
        (when (not
               (timerp pils--list-depth-timer))
          (setq pils--list-depth-timer
                (run-with-timer
                 0.2 0.2
                 #'pils/list-depth)))
        (format " (%s) " pils--list-depth-cache))
    (when (timerp pils--list-depth-timer)
      (cancel-timer pils--list-depth-timer)
      (setq pils--list-depth-timer nil)
      (setq pils--list-depth-cache nil))
    ""))
#+end_src

Now we can use it in the default mode-line :
#+begin_src
(setq-default mode-line-format
              '("%e" mode-line-front-space
                mode-line-mule-info
                mode-line-client
                mode-line-modified
                mode-line-remote
                mode-line-frame-identification
                mode-line-buffer-identification
                "%l-%c"
                (:eval (pils--modeline-list-depth))
                (vc-mode vc-mode)
                " "
                mode-line-modes
                mode-line-misc-info
                mode-line-end-spaces))
#+end_src

** little tips
*** using imenu :week3:

[[elisp:(info "(elisp) Imenu")][~imenu~ is a powerful tool.]]
It can be used with a completion engine to navigate very easily in documents.
With helm, its integrated command it ~helm-imenu~ that is bound to =C-x c i=.

*** org links :week3:

[[elisp:(info "(org) Hyperlinks")][We start to have a lot of org links in this document.]]
I use them often to point to the relevant pages of the Info manuals (and that one of the reasons that it is important to read this file inside Emacs).
To consult them, use =C-c C-o= that runs ~org-open-at-point~.

*** org tags :week3:

I started to tag the org headings to give them a numerated week.
[[elisp:(info "(org) Tags")][Tags can be used in conjunction of ~org-agenda~ & cie for your own purpose.]]
There is an useful command to narrow the view to only some tags ~org-sparse-tree~ that is bound to =C-c /=.

** using git within emacs
*** choosing the right interface :week3:

As we uses git as backend, it needs to be configured with an identity :
#+BEGIN_SRC sh
git config --global user.name "my full name"
git config --global user.email "my.address@somemail.com"
#+END_SRC

Also it may be worthwhile to add this snippet in ~/.bashrc or ~/.zhsrc to specify to our shell that we want him to uses ~emacsclient~ when, eg, committing changes with git. Since we have already put in the init file (server-start), the server should be running and this should work at expected.

#+begin_src bash
if [ -n "$ZSH_VERSION" ]; then emulate -L sh; fi

if [ -z "${EDITOR}" ] ; then
  export EDITOR='emacsclient'
fi
if [ -n "${EDITOR}" ] && [ -z "${VISUAL}" ] ; then
  export VISUAL="${EDITOR}"
fi
#+end_src

Emacs have natively the vc library and, indeed, Magit is very popular these days.

Magit with its transient interface, is maybe more difficult to apprehend when the instruction does not fit the window and the way to get its binding in a non-transient buffer it to ask for the help of the major mode, or to consult its manual, eg :

_To get help buffer for prefix map of vc_, Start typing =C-x v= then =C-h=

_To get help buffer for the major mode of magit (no prefix map available by default)_, Start typing =C-x g= then =C-h m=.

#+CAPTION: Magit and its transient map are not the most accessible interface
[[file:Emacs_3.png]]

[[https://github.com/magit/magit/issues/4408][I started an issue at this subject.]]

~vc~ is a library that can be used with many others version control software, not only git, and have less commands for git.

That's being say, let's see a basic workflow with ~vc~ :

**** a basic workflow with vc :week3:

[[elisp:(info "(emacs) Version Control")][vc is documented in the emacs manual]], (not the elisp one).

In a directory under version control,

  1. At any time, I can use =C-x v l= that runs the command ~vc-print-log~ to see the locals logs of the version control system. In this buffer I can get informations about the bindings available with =C-x h m= or simply =?=. A notable command here is === that run ~log-view-diff= on the commit at point.

  2. I want to check the changes of the remote repository, I can use =C-x v I= that runs ~vc-log-incoming~ to see what they are (maybe none).

  3. If there are changes on the remote repository, I surely want to pull them and I can use =C-x v += that runs the command ~vc-update~ that is an alias to ~vc-pull~. As usual if there is non commited changes on the directory, we will be warned to commit them before trying to merge the remote changes.

  4. I have non commited changes, I want informations about them *--also see 7.!*, I can use =C-x v ==  runs the command ~vc-diff~.
[[elisp:(info "(emacs) Old Revisions")][vc-diff is documented itself in (emacs) Old Revisions]], while the [[elisp:(info "(emacs) Diff Mode")][the diff mode have its own pages in (emacs) Diff Mode]] and allow to interactively manipulate diff buffers and eg, choose what hunks apply or revert .
    4.1 with =C-c C-a= that runs ~diff-apply-hunk~, I can apply hunks or revert them with =C-u= an ~universal-argument~.
    4.2 with =C-c C-c= that runs ~diff-goto-source~, I can go to the source to modify my change before committing them.
    4.3 with =g= that runs ~revert-buffer~, I can actualise the buffer with the new changes applied.
    4.4 with =C-x 4 A=, I can generate a changelog entry to later use in the commit message.

  5. I am done with revising the changes, I want to commit. I can uses the DWIM (Do What I Mean) command =C-x v v= runs the command ~vc-next-action~. I am prompted to commit my changes, I can make my commit and validate it with =C-c C-c= and ask for the next action again with =C-x v v=.

  6. Eventually there will be conflicting changes between my local files and the remote one. So =C-x v v= may have triggered the command =C-x v m= ~vc-merge~. At this point I think Emacs put automatically the targeted files in ~smerge-mode~ that enable a special view and commands. I did not find much information about it in the manual but  [[elisp:(describe-function 'smerge-mode)][asking to describe the function will show you informations about its keymap]] and
    6.1 we can quickly choose what hunks to keep with =C-c ^ u= ~smerge-keep-upper~
    6.2 =C-c ^ l= ~smerge-keep-lower~
    6.3 and going directly to the next conflict with =C-c ^ n= ~smerge-next~. Note that there is more commands and I should spend a little more time to understand them.
  When done =C-x v += should respond we are up to date.

  7. Here I am a little bit confused about ~vc~ and its git integration, ~vc~ prompted me to commit changes at step 4. but now if I do changes again, I see no exposed commands to stage and commit them. So I need to do that from a shell with ‘git stage’ and ‘git commit -a’.

  8. After committed new changes again, I want to push my locals changes to the remote repository. I can use =C-x v O= that runs ~vc-log-outgoing~ to see what will be done by =C-x v P= that runs ~vc-push~.

*** (a bit more involved) integration with the forges

But we may also install the ~forge~ package to get a more complete integration with specific forges as github to being able to eg, make a pull request to a repository and merge one.

#+begin_src emacs-lisp
(use-package forge)
#+end_src

[[https://www.youtube.com/watch?v=fFuf3hExF5w][Zaiste makes a video about it]]

[[https://github.com/settings/tokens/new][We need to go to the tokens settings of our user account to create one]].

Once done we can use this password in the same authinfo file we already created for the mails but this time the parameters will looks like :

#+begin_comment
machine api.github.com login <user-name>^forge password <password>
#+end_comment

No port seems required and ‘forge’ is the application name you previously named when creating the token.

Now we should be able to see pull requests from github and to merge them.

** local variables

# Local Variables:
# org-tags-column: 0
# End:
